name: Build and Push to ECR

on:
  push:
    branches:
      - main

jobs:
  build-and-push:

    env:
        ECR_REPO: ${{ vars.ECR_REPO }}  
        IMAGE_TAG: v${{ github.run_number }}
        APP_PORT: ${{ vars.APP_PORT }}

        TASK_DEFINITION: task-definition.json         # Путь к файлу после скачивания
        CONTAINER_NAME: backend-container             # = var.container_name
        ECS_CLUSTER: backend-cluster                  # = var.ecs_cluster_name
        ECS_SERVICE: ecs-service                      # = var.ecs_service_name

    runs-on: ubuntu-latest
    
    steps:
     
    - name: Checkout code
      uses: actions/checkout@v4

 # скачиваем с приваиного репозитория файл с определением задачи ECS,
 # качаем после скачивания кода, чтобы не перезаписали 
    - name: Download task definition from private repo
      run: |
        curl -H "Authorization: token ${{ secrets.WORKFLOWS_REPO_PAT }}" \
              -H "Accept: application/vnd.github.v3.raw" \
              -L https://api.github.com/repos/pablo-buenos-aires/workflows/contents/.github/workflows/backend/ecs/task-definition.json \
              -o task-definition.json
        echo "Task definition downloaded successfully"
        ls -la task-definition.json
        echo "--- Content preview:"
        head -n 13 task-definition.json

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Login to Amazon ECR/ Сохраняет результат  под id login-ecr
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
 
    - name: Build, tag, and push image to  Amazon ECR. 
      run: |
        docker build --build-arg APP_PORT=$APP_PORT -t $ECR_REPO:$IMAGE_TAG .
        docker tag $ECR_REPO:$IMAGE_TAG $ECR_REPO:latest 
        docker push $ECR_REPO:$IMAGE_TAG
        docker push $ECR_REPO:latest

    - name: Output image details
      run: |
        echo "--- APP_PORT $APP_PORT"
        echo "--- Image pushed to ECR"
        echo "--- Full Image: $ECR_REPO:$IMAGE_TAG"

    # - name: Update task definition with new image
    #   run: |
    #     NEW_IMAGE="${ECR_REPO}:${IMAGE_TAG}"
    #     echo "--- Updating image in task definition"
    #     echo "--- Container name: $CONTAINER_NAME"
    #     echo "--- New image: $NEW_IMAGE"
        
    #     # Обновляем image для указанного контейнера
    #     # находит контейнер с именем backend-container в массиве containerDefinitions 
    #     # и обновляет его поле image на новый образ из ECR

    #     jq --arg container "$CONTAINER_NAME" --arg image "$NEW_IMAGE" \
    #       '(.containerDefinitions[] | select(.name == $container) | .image) = $image' \
    #       $TASK_DEFINITION > task-definition-updated.json
        
    #     # Заменяем оригинальный файл
    #     mv task-definition-updated.json $TASK_DEFINITION
        
    #     echo "--- Task definition updated successfully"
    
    # - name: Show updated task definition
    #   run: |
    #       echo "--- Updated task definition:"
    #       cat $TASK_DEFINITION

    # - name: Deploy  to ECS
    #   uses: aws-actions/amazon-ecs-deploy-task-definition@v2
    #   with:
    #     task-definition: ${{ env.TASK_DEFINITION }}
    #     service: ${{ env.ECS_SERVICE }}
    #     cluster: ${{ env.ECS_CLUSTER }}
    #     wait-for-service-stability: true

    # ----------------------- new update service method -----------------------
          # ШАГ 1: Обновляем image для ВСЕХ контейнеров с именем $CONTAINER_NAME
    - name: Update task definition with new image
      run: |
        NEW_IMAGE="${ECR_REPO}:${IMAGE_TAG}"
        echo "--- Updating image in task definition"
        echo "--- Container name: $CONTAINER_NAME"
        echo "--- New image: $NEW_IMAGE"
        
        # Обновляем image для ВСЕХ контейнеров с именем $CONTAINER_NAME
        # map обрабатывает каждый элемент массива
        jq --arg container "$CONTAINER_NAME" --arg image "$NEW_IMAGE" \
          '.containerDefinitions |= map(
            if .name == $container then 
              .image = $image 
            else 
              . 
            end
          )' \
          $TASK_DEFINITION > task-definition-updated.json
        
        # Заменяем оригинальный файл
        mv task-definition-updated.json $TASK_DEFINITION
        
        echo "✓ Task definition updated successfully"
    
    - name: Show updated task definition
      run: |
          echo "--- Updated task definition:"
          cat $TASK_DEFINITION
  
       # ШАГ 2: Регистрируем новую версию task definition в ECS
    - name: Register new task definition revision
      id: register-task-def
      run: |
        echo "--- Registering new task definition revision..."
        
        # Регистрируем новую версию task definition и сохраняем результат
        TASK_DEF_ARN=$(aws ecs register-task-definition \
          --cli-input-json file://$TASK_DEFINITION \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        
        # Проверяем что ARN получен
        if [ -z "$TASK_DEF_ARN" ]; then
          echo "ERROR: Failed to register task definition"
          exit 1
        fi
        
        echo "✓ New task definition registered"
        echo "--- Task Definition ARN: $TASK_DEF_ARN"
        
        # Сохраняем ARN для использования в следующих шагах
        echo "TASK_DEF_ARN=$TASK_DEF_ARN" >> $GITHUB_ENV
        
        # Извлекаем номер ревизии (например: backend-task:42)
        REVISION=$(echo $TASK_DEF_ARN | rev | cut -d':' -f1 | rev)
        echo "--- Revision number: $REVISION"
        echo "TASK_DEF_REVISION=$REVISION" >> $GITHUB_ENV

# Проверяем существование сервиса
    - name: Verify ECS service exists
      run: |
        echo "--- Verifying ECS service exists..."
        echo "--- Cluster: $ECS_CLUSTER"
        echo "--- Service: $ECS_SERVICE"
        
        # Проверяем существование сервиса
        SERVICE_EXISTS=$(aws ecs describe-services \
          --cluster $ECS_CLUSTER \
          --services $ECS_SERVICE \
          --query 'services[0].status' \
          --output text 2>/dev/null || echo "NOT_FOUND")
        
        if [ "$SERVICE_EXISTS" = "NOT_FOUND" ] || [ "$SERVICE_EXISTS" = "None" ]; then
          echo "ERROR: Service '$ECS_SERVICE' not found in cluster '$ECS_CLUSTER'"
          echo "--- Available services in cluster:"
          aws ecs list-services --cluster $ECS_CLUSTER --output table
          exit 1
        fi
        
        echo "✓ Service found with status: $SERVICE_EXISTS" 

# ШАГ 3: Обновляем ECS сервис с новой версией task definition
    - name: Update ECS service
      run: |
        echo "--- Updating ECS service: $ECS_SERVICE"
        echo "--- Cluster: $ECS_CLUSTER"
        echo "--- Task Definition: $TASK_DEF_ARN"
        
        # Проверяем что ARN доступен
        if [ -z "$TASK_DEF_ARN" ]; then
          echo "ERROR: TASK_DEF_ARN is empty"
          exit 1
        fi
        
        # Обновляем сервис с новой task definition
        aws ecs update-service \
          --cluster $ECS_CLUSTER \
          --service $ECS_SERVICE \
          --task-definition $TASK_DEF_ARN \
          --force-new-deployment \
          --output json > service-update-result.json
        
        echo "✓ ECS service update initiated"
        
        # Показываем краткую информацию об обновлении 
        echo "--- Service update details:"
        jq '.service | {
          serviceName: .serviceName,
          status: .status,
          desiredCount: .desiredCount,
          runningCount: .runningCount,
          taskDefinition: .taskDefinition
        }' service-update-result.json
    
    # ШАГ 4: Ожидаем стабильности сервиса (деплоймент завершен)
    - name: Wait for service stability
      run: |
        echo "--- Waiting for service to become stable..."
        echo "--- This may take several minutes depending on your deployment configuration"
        
        # Ожидаем пока сервис достигнет стабильного состояния
        # Timeout по умолчанию: 10 минут (600 секунд)
        # Проверяет каждые 15 секунд
        aws ecs wait services-stable \
          --cluster $ECS_CLUSTER \
          --services $ECS_SERVICE
        
        echo "✓ Service is now stable"
    
    # ШАГ 5: Показываем финальный статус сервиса
    - name: Show final service status
      run: |
        echo "--- Final service status:"
        
        aws ecs describe-services \
          --cluster $ECS_CLUSTER \
          --services $ECS_SERVICE \
          --query 'services[0] | {
            serviceName: serviceName,
            status: status,
            desiredCount: desiredCount,
            runningCount: runningCount,
            taskDefinition: taskDefinition,
            deployments: deployments[*].{
              status: status,
              taskDefinition: taskDefinition,
              desiredCount: desiredCount,
              runningCount: runningCount,
              createdAt: createdAt
            }
          }' \
          --output json | jq .
        
        echo "✓ Deployment completed successfully!"
        echo "--- Image: $ECR_REPO:$IMAGE_TAG"
        echo "--- Task Definition Revision: $TASK_DEF_REVISION"