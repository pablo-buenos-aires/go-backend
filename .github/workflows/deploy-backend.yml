name: Build and Push to ECR

permissions:
  id-token: write   # нужно для OIDC → AWS STS
  # contents: read    # checkout

on:
  push:
    branches:
      - main

jobs:

  #quality:
    # runs-on: ubuntu-latest
    # steps:
    #   - uses: pablo-buenos-aires/workflow-actions/quality@main
    #     with:
    #       sonar-token: ${{ secrets.SONAR_TOKEN }}
    #       go-version: "1.22"

    

  deploy: 
    runs-on: ubuntu-latest
    #needs: [quality]   # <-- ДЕПЛОЙ ТОЛЬКО ПОСЛЕ QUALITY
    env:
        ECR_REPO: ${{ vars.ECR_REPO }}  
        IMAGE_TAG: v${{ github.run_number }}
        APP_PORT: ${{ vars.APP_PORT }}

        TASK_DEFINITION: task-definition.json         # Путь к файлу после скачивания
        CONTAINER_NAME: backend-container             # = var.container_name
        ECS_CLUSTER: backend-cluster                  # = var.ecs_cluster_name
        ECS_SERVICE: ecs-service                      # = var.ecs_service_name

    steps:
    - uses: actions/checkout@v4
  # скачиваем с приваиного репозитория файл с определением задачи ECS,
  # качаем после скачивания кода, чтобы не перезаписали 
    - uses: pablo-buenos-aires/workflow-actions/download-taskdef@main
      with:
        github-token: ${{ secrets.WORKFLOWS_REPO_PAT }}
        taskdef-url: https://api.github.com/repos/pablo-buenos-aires/workflows/contents/.github/workflows/backend/ecs/task-definition.json
  #      output: ${{ env.TASK_DEFINITION }}

    # - name: Download task definition from pr ivate repo
    #   run: |
    #     curl -H "Authorization: token ${{ secrets.WORKFLOWS_REPO_PAT }}" \
    #           -H "Accept: application/vnd.github.v3.raw" \
    #           -L https://api.github.com/repos/pablo-buenos-aires/workflows/contents/.github/workflows/backend/ecs/task-definition.json \
    #           -o task-definition.json
    #     echo "Task definition downloaded successfully"
    #     ls -la task-definition.json
    #     echo "--- Content preview:"
    #     head -n 13 task-definition.json

    # Configure AWS credentials (OIDC)
    - uses: pablo-buenos-aires/workflow-actions/aws-oidc-creds@main
      with:
        role-to-assume: arn:aws:iam::836940249137:role/gitHubActionsDeployRole
        aws-region: sa-east-1
  
    # - name: Configure AWS credentials (OIDC)
    #   uses: aws-actions/configure-aws-credentials@v4
    #   with:
    #     role-to-assume: arn:aws:iam::836940249137:role/gitHubActionsDeployRole
    #     aws-region: sa-east-1

    - uses: pablo-buenos-aires/workflow-actions//ecr-build-push@main
      with:
          ecr-repo: ${{ env.ECR_REPO }}
          image-tag: ${{ env.IMAGE_TAG }}
          app-port: ${{ env.APP_PORT }}

    # ----------------------- old build and push method -----------------------
    # - name: Login to Amazon ECR/ Сохраняет результат  под id login-ecr
    #   id: login-ecr
    #   uses: aws-actions/amazon-ecr-login@v1
 
    # - name: Build, tag, and push image to  Amazon ECR. 
    #   run: |
    #     docker build --build-arg APP_PORT=$APP_PORT -t $ECR_REPO:$IMAGE_TAG .
    #     docker tag $ECR_REPO:$IMAGE_TAG $ECR_REPO:latest 
    #     docker push $ECR_REPO:$IMAGE_TAG
    #     docker push $ECR_REPO:latest

    # - name: Output image details
    #   run: |
    #     echo "--- APP_PORT $APP_PORT"
    #     echo "--- Image pushed to ECR"
    #     echo "--- Full Image: $ECR_REPO:$IMAGE_TAG"
    - uses: pablo-buenos-aires/workflow-actions/ecs-deploy@main
      with:
        task-definition: ${{ env.TASK_DEFINITION }}
        container-name: ${{ env.CONTAINER_NAME }}
        new-image: ${{ env.ECR_REPO }}:${{ env.IMAGE_TAG }}
        ecs-cluster: ${{ env.ECS_CLUSTER }}
        ecs-service: ${{ env.ECS_SERVICE }}
    # ----------------------- old update service method -----------------------
    # Обновляем image для ВСЕХ контейнеров с именем $CONTAINER_NAME
#     - name: Update task definition with new image
#       run: |
#         NEW_IMAGE="${ECR_REPO}:${IMAGE_TAG}"
#         echo "--- Updating image in task definition"
#         echo "--- Container name: $CONTAINER_NAME"
#         echo "--- New image: $NEW_IMAGE"
        
#         # Обновляем image для ВСЕХ контейнеров с именем $CONTAINER_NAME
#         # map обрабатывает каждый элемент массива
#         jq --arg container "$CONTAINER_NAME" --arg image "$NEW_IMAGE" \
#           '.containerDefinitions |= map(
#             if .name == $container then 
#               .image = $image 
#             else 
#               . 
#             end
#           )' \
#           $TASK_DEFINITION > task-definition-updated.json
        
#         # Заменяем оригинальный файл
#         mv task-definition-updated.json $TASK_DEFINITION
        
#         echo "✓ Task definition updated successfully"
    
#     - name: Show updated task definition
#       run: |
#           echo "--- Updated task definition:"
#           cat $TASK_DEFINITION
  
#        # ШАГ 2: Регистрируем новую версию task definition в ECS
#     - name: Register new task definition revision
#       id: register-task-def
#       run: |
#         echo "--- Registering new task definition revision..."
        
#         # Регистрируем новую версию task definition и сохраняем результат
#         TASK_DEF_ARN=$(aws ecs register-task-definition \
#           --cli-input-json file://$TASK_DEFINITION \
#           --query 'taskDefinition.taskDefinitionArn' \
#           --output text)
        
#         # Проверяем что ARN получен
#         if [ -z "$TASK_DEF_ARN" ]; then
#           echo "ERROR: Failed to register task definition"
#           exit 1
#         fi
        
#         echo "✓ New task definition registered"
#         echo "--- Task Definition ARN: $TASK_DEF_ARN"
        
#         # Сохраняем ARN для использования в следующих шагах
#         echo "TASK_DEF_ARN=$TASK_DEF_ARN" >> $GITHUB_ENV
        
#         # Извлекаем номер ревизии (например: backend-task:42)
#         REVISION=$(echo $TASK_DEF_ARN | rev | cut -d':' -f1 | rev)
#         echo "--- Revision number: $REVISION"
#         echo "TASK_DEF_REVISION=$REVISION" >> $GITHUB_ENV

# # Проверяем существование сервиса
#     - name: Verify ECS service exists
#       run: |
#         echo "--- Verifying ECS service exists..."
#         echo "--- Cluster: $ECS_CLUSTER"
#         echo "--- Service: $ECS_SERVICE"
        
#         # Проверяем существование сервиса
#         SERVICE_EXISTS=$(aws ecs describe-services \
#           --cluster $ECS_CLUSTER \
#           --services $ECS_SERVICE \
#           --query 'services[0].status' \
#           --output text 2>/dev/null || echo "NOT_FOUND")
        
#         if [ "$SERVICE_EXISTS" = "NOT_FOUND" ] || [ "$SERVICE_EXISTS" = "None" ]; then
#           echo "ERROR: Service '$ECS_SERVICE' not found in cluster '$ECS_CLUSTER'"
#           echo "--- Available services in cluster:"
#           aws ecs list-services --cluster $ECS_CLUSTER --output table
#           exit 1
#         fi
        
#         echo "✓ Service found with status: $SERVICE_EXISTS" 

# # ШАГ 3: Обновляем ECS сервис с новой версией task definition
#     - name: Update ECS service
#       run: |
#         echo "--- Updating ECS service: $ECS_SERVICE"
#         echo "--- Cluster: $ECS_CLUSTER"
#         echo "--- Task Definition: $TASK_DEF_ARN"
        
#         # Проверяем что ARN доступен
#         if [ -z "$TASK_DEF_ARN" ]; then
#           echo "ERROR: TASK_DEF_ARN is empty"
#           exit 1
#         fi
        
#         # Обновляем сервис с новой task definition
#         aws ecs update-service \
#           --cluster $ECS_CLUSTER \
#           --service $ECS_SERVICE \
#           --task-definition $TASK_DEF_ARN \
#           --force-new-deployment \
#           --output json > service-update-result.json
        
#         echo "✓ ECS service update initiated"
        
#         # Показываем краткую информацию об обновлении 
#         echo "--- Service update details:"
#         jq '.service | {
#           serviceName: .serviceName,
#           status: .status,
#           desiredCount: .desiredCount,
#           runningCount: .runningCount,
#           taskDefinition: .taskDefinition
#         }' service-update-result.json
    
#     # ШАГ 4: Ожидаем стабильности сервиса (деплоймент завершен)
#     - name: Wait for service stability
#       run: |
#         echo "--- Waiting for service to become stable..."
#         echo "--- This may take several minutes depending on your deployment configuration"
        
#         # Ожидаем пока сервис достигнет стабильного состояния
#         # Timeout по умолчанию: 10 минут (600 секунд)
#         # Проверяет каждые 15 секунд
#         aws ecs wait services-stable \
#           --cluster $ECS_CLUSTER \
#           --services $ECS_SERVICE
        
#         echo "✓ Service is now stable"
    
#     # ШАГ 5: Показываем финальный статус сервиса
#     - name: Show final service status
#       run: |
#         echo "--- Final service status:"
        
#         aws ecs describe-services \
#           --cluster $ECS_CLUSTER \
#           --services $ECS_SERVICE \
#           --query 'services[0] | {
#             serviceName: serviceName,
#             status: status,
#             desiredCount: desiredCount,
#             runningCount: runningCount,
#             taskDefinition: taskDefinition,
#             deployments: deployments[*].{
#               status: status,
#               taskDefinition: taskDefinition,
#               desiredCount: desiredCount,
#               runningCount: runningCount,
#               createdAt: createdAt
#             }
#           }' \
#           --output json | jq .
        
#         echo "✓ Deployment completed successfully!"
#         echo "--- Image: $ECR_REPO:$IMAGE_TAG"
#         echo "--- Task Definition Revision: $TASK_DEF_REVISION"